from argparse import ArgumentParser
from sys import argv
from json import loads
from datetime import datetime
from os import makedirs

from caddieutil.stream import OutputStream, StreamEndian
from caddieutil.message import CMSGBlock, DESCBlock, DATABlock

BCMSG_HEADER_ROOT = "src/caddie/"


def write_binary(messages: list[str], args):
    """Write specified messages to BCMSG binary"""
    try:
        strm = OutputStream(args.outfile, StreamEndian.BIG)
    except OSError:
        print(f"[FATAL] Could not open BCMSG file for writing: {args.outfile}")
        return

    # Create blocks
    data = DATABlock(messages)
    desc = data.gen_desc()
    cmsg = CMSGBlock([desc, data])

    # Write to file
    cmsg.write(strm)

    strm.close()


def write_header(message_keys: list[str], args, header_path):
    """Write C++ header file for use with the BCMSG binary"""

    # Get file name from JSON path
    last_dir_idx = max(args.infile.rfind("/"), args.infile.rfind("\\"))
    file_ext_idx = args.infile.rfind(".")
    file_name = args.infile[last_dir_idx+1:file_ext_idx]

    # Correct header path
    if header_path != "" and not header_path.endswith("/"):
        header_path = f"{header_path}/"

    # Path to header file
    header_dir = f"{BCMSG_HEADER_ROOT}{header_path}"
    header_path = f"{header_dir}BCMSG_{file_name}.h"

    # Create header directory if it doesn't exist
    makedirs(header_dir, exist_ok=True)

    with open(header_path, "w+") as f:
        # Comment from tool
        now = datetime.now()
        f.write("/**\n")
        f.write(
            f" * Auto-generated by make_message.py on {now.strftime('%m/%d/%Y (%H:%M:%S)')}\n")
        f.write(" * Don't edit this unless you know what you are doing,\n")
        f.write(" * as manual changes will be overwritten on the next build.\n")
        f.write(" */\n")

        f.write("\n")

        # Begin header guard
        f.write(f"#ifndef BCMSG_{file_name.upper()}_H\n")
        f.write(f"#define BCMSG_{file_name.upper()}_H\n")

        f.write("\n")

        # Begin caddie namespace
        f.write("namespace caddie {\n")

        f.write("\n")

        f.write(f"enum BCMSG_{file_name} {{\n")
        for msg_key in message_keys:
            f.write(f"    {msg_key},\n")
        f.write("};\n")

        f.write("\n")

        # End caddie namespace
        f.write("} // namespace caddie\n")

        f.write("\n")

        # End header guard
        f.write(f"#endif\n")


def convert_json(args):
    """Parse and validate JSON message file, before converting it to binary form"""

    # Attempt to decode JSON data
    try:
        with open(args.infile, "rb") as f:
            json_data = loads(f.read())
    except FileNotFoundError:
        print(f"[FATAL] JSON file could not be opened: {args.infile}")
        return
    except UnicodeDecodeError:
        print(f"[FATAL] JSON data could not be decoded: {args.infile}")
        return

    # Message data
    msg_messages = json_data.get("messages", [])
    if len(msg_messages) == 0:
        print("[FATAL] No messages exist in the JSON file")
        return

    # Header path (optional)
    # *RELATIVE TO CMSG_HEADER_ROOT*
    header_path = json_data.get("header_dir", "")

    # BCMSG binary
    write_binary(msg_messages.values(), args)
    # Generate C++ header
    write_header(msg_messages.keys(), args, header_path)


def main():
    # Parse command-line arguments
    parser = ArgumentParser()
    parser.add_argument("--infile", type=str, required=True,
                        help="CMSG (JSON) file from which to create message binary")
    parser.add_argument("--outfile", type=str, required=True,
                        help="(BCMSG) Path to output message binary")
    args = parser.parse_args(argv[1:])

    convert_json(args)


if __name__ == "__main__":
    main()
