from argparse import ArgumentParser
from sys import argv
from json import loads
from datetime import datetime
from os import makedirs

from caddieutil.stream import OutputStream, StreamEndian
from caddieutil.message import CMSGBlock, DESCBlock, DATABlock


def write_binary(messages: list[str], args):
    """Write specified messages to BCMSG binary"""
    try:
        strm = OutputStream(args.outfile, StreamEndian.BIG)
    except OSError:
        print(f"[FATAL] Could not open BCMSG file for writing: {args.outfile}")
        return

    # Create blocks
    data = DATABlock(messages)
    desc = data.gen_desc()
    cmsg = CMSGBlock([desc, data])

    # Write to file
    cmsg.write(strm)

    strm.close()


def write_header(message_keys: list[str], args, header_path):
    """Write C++ header file for use with the BCMSG binary"""

    # Autogenerate header path if not specified
    if header_path == None:
        # Split up JSON path
        last_dir_idx = max(args.infile.rfind("/"), args.infile.rfind("\\"))
        file_ext_idx = args.infile.rfind(".")

        file_name = args.infile[last_dir_idx+1:file_ext_idx]
        file_dir = args.infile[:last_dir_idx+1]

        # Ideally, "assets/*" maps to "src/*", so for autogenerating this path,
        # we rely on the CMSG being somewhere inside the assets folder.
        if "assets" not in file_dir:
            print("[FATAL] CMSG file not in Caddie assets folder! I do not know where to put the header file, please specify using --header.")
            return

        # Path to header file
        header_dir = file_dir.replace("assets", "src")
        header_path = f"{header_dir}BCMSG_{file_name}.hpp"

    # Create header directory if it doesn't exist
    makedirs(header_dir, exist_ok=True)

    with open(header_path, "w+") as f:
        # Comment from tool
        now = datetime.now()
        f.write("/**\n")
        f.write(
            f" * Auto-generated by make_message.py on {now.strftime('%m/%d/%Y (%H:%M:%S)')}\n")
        f.write(" * Don't edit this unless you know what you are doing,\n")
        f.write(" * as manual changes will be overwritten on the next build.\n")
        f.write(" */\n")

        f.write("\n")

        # Begin header guard
        f.write(f"#ifndef BCMSG_{file_name.upper()}_H\n")
        f.write(f"#define BCMSG_{file_name.upper()}_H\n")

        f.write("\n")

        # Begin caddie namespace
        f.write("namespace caddie {\n")

        f.write("\n")

        f.write(f"enum BCMSG_{file_name} {{\n")
        for msg_key in message_keys:
            f.write(f"    {msg_key},\n")
        f.write("};\n")

        f.write("\n")

        # End caddie namespace
        f.write("} // namespace caddie\n")

        f.write("\n")

        # End header guard
        f.write(f"#endif\n")


def convert_json(args):
    """Parse and validate JSON message file, before converting it to binary form"""

    # Attempt to decode JSON data
    try:
        with open(args.infile, "rb") as f:
            json_data = loads(f.read())
    except FileNotFoundError:
        print(f"[FATAL] JSON file could not be opened: {args.infile}")
        return
    except UnicodeDecodeError:
        print(f"[FATAL] JSON data could not be decoded: {args.infile}")
        return

    # Message data
    msg_messages = json_data.get("messages", [])
    if len(msg_messages) == 0:
        print("[FATAL] No messages exist in the JSON file")
        return

    # BCMSG binary
    write_binary(msg_messages.values(), args)
    # Generate C++ header
    write_header(msg_messages.keys(), args, args.header)


def main():
    # Parse command-line arguments
    parser = ArgumentParser()
    parser.add_argument("--infile", type=str, required=True,
                        help="CMSG (JSON) file from which to create message binary")
    parser.add_argument("--outfile", type=str, required=True,
                        help="(BCMSG) Path to output message binary")
    parser.add_argument("--header", type=str, required=False,
                        help="Path to C++ header file")
    args = parser.parse_args(argv[1:])

    convert_json(args)


if __name__ == "__main__":
    main()
